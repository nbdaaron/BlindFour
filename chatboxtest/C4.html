<html>
	<head>
		<title>Connect 4 Board?</title>
	</head>
	<body>
		<canvas id="back" width = 490 height=480><p>Ur browser sux u can't even load da game lolz</p></canvas>

	</body>

	<script>
	var back = document.getElementById("back");
	var board = document.createElement("canvas");
	var grid = new Array(6);
	var player1 = true;
	var enabled = true;

	for (var i=0;i<grid.length;i++) {
		grid[i]= new Array(7);
	}

	board.width="490";
	board.height="480";
	back.addEventListener("mouseup", mouseClick, false);
	var backContext = back.getContext("2d");

	var context = board.getContext("2d");
	var pieces = new Array();
	var lastPiece = -1;
	var currPlay;
	
	
	//context.restore();
	resetGame();
	backContext.drawImage(board,0,0);

	backContext.fillStyle="white";
	backContext.globalCompositeOperation = "destination-over";
	backContext.fillRect(0, 0, 490, 480);

	function play(colo, colu, row) {
		pieces[++lastPiece] = {
			col: colo,
			c: parseInt(colu),
			r: parseInt(row), 
			y: 0
		};
		console.log(colo + " " + colu + " " + row);
		grid[parseInt(row)][parseInt(colu)] = colo;
		currPlay = setInterval(dropPiece, 20);
		var win = checkWin(colo, parseInt(colu), parseInt(row));
		if (win != null) winner(win);
	}

	function checkWin(color, col, row) {
		var win = false;
		//CHECK VERTICAL ROW
		var count=0;
		for (var i=0;i<grid.length;i++) {
			if (grid[i][col] == color) count++;
			else count=0;
			if (count>=4) return {
				type: "vertical",
				c: color,
				fromc: col,
				toc: col,
				fromr: i,
				tor: i-3
			};
		}

		//CHECK HORIZONTAL ROW
		count = 0;
		for (var i=0;i<grid[0].length;i++) {
			if (grid[row][i] == color)count++;
			else count=0;
			if(count>=4) return {
				type: "horizontal",
				c: color,
				fromc: i-3,
				toc: i,
				fromr: row,  
				tor: row
			};
		}

		count = 0;
		var startc=col, startr=row;
		while (startc>0 && startr > 0) {
			startc--;
			startr--;
		}
		console.log(startc + " " + startr);
		while (startc<grid[0].length && startr < grid.length) {
			if (grid[startr][startc] == color) count++;
			else count=0;
			if (count >= 4) return {
				type: "d1",
				c: color,
				fromc: startc-3,
				toc: startc,
				fromr: startr-3,
				tor: startr
			}
			startr++;
			startc++;
			console.log(startc + " " + startr);
		}

		count=0;
		startc=col, startr=row;
		while (startc<grid[0].length-1 && startr > 0) {
			startc++;
			startr--;
		}
		//console.log(startc + " " + startr);
		while (startc>=0 && startr < grid.length) {
			if (grid[startr][startc] == color) count++;
			else count=0;
			if (count >= 4) return {
				type: "d2",
				c: color,
				fromc: startc+3,
				toc: startc,
				fromr: startr-3,
				tor: startr
			}
			startr++;
			startc--;
			//console.log(startc + " "+ startr);
		}		

		return null;

	}

	function winner(stats) {
		enabled = false;
		drawLine(stats.fromc, stats.fromr, stats.toc, stats.tor);
		alert(stats.c + " wins!!!");
	}

	function dropPiece() {
		backContext.clearRect(0, 0, back.width, back.height);
		backContext.drawImage(board, 0, 0);
		if (lastPiece>=0 && pieces[lastPiece].y>=board.height/12+board.height/6*pieces[lastPiece].r) {
			pieces[lastPiece].y = board.height/12+board.height/6*pieces[lastPiece].r;
			for (var i=0;i<=lastPiece;i++) {
				backContext.fillStyle = pieces[i].col;
				backContext.beginPath();
				backContext.arc(board.width/14 + board.width/7*pieces[i].c, board.height/12 + board.height/6*pieces[i].r, 30, 0, 2*Math.PI, true);
				backContext.closePath();
				backContext.fill();
			}
			clearInterval(currPlay);
			return;
		}
		else if (lastPiece >= 0) {
			for (var i=0;i<lastPiece;i++) {
				backContext.fillStyle = pieces[i].col;
				backContext.beginPath();
				backContext.arc(board.width/14 + board.width/7*pieces[i].c, board.height/12 + board.height/6*pieces[i].r, 30, 0, 2*Math.PI, true);
				backContext.closePath();
				backContext.fill();
			}
			backContext.fillStyle = pieces[lastPiece].col;
			backContext.beginPath();
			backContext.arc(board.width/14 + board.width/7*pieces[i].c, pieces[lastPiece].y, 30, 0, 2*Math.PI, true);
			pieces[lastPiece].y += 10;
			backContext.closePath();
			backContext.fill();
		}
	}

	function getCursorPosition(canvas, event) {
	    var rect = canvas.getBoundingClientRect();
	    var x = event.clientX - rect.left;
	    var y = event.clientY - rect.top;
	    //console.log("x: " + x + " y: " + y);
	    return {
	    	x: x,
	    	y: y
	    };
	}

	function getColFromPos(pos) {
		var colWidth = board.width/7;
		if (pos.x == board.width) return 6;
		return (pos.x/colWidth);
	}

	function mouseClick(event) {
		if (!enabled) return;
		var col = getColFromPos(getCursorPosition(back, event));
		for (var i=grid.length-1;i>=0;i--) {
			if (grid[parseInt(i)][parseInt(col)] == null){
				console.log("col: " + col + " row: " + i);
				play(player1?"yellow":"green", col, i);
				player1 = !player1;
				return;
			}
		}
	}

	function drawLine(startc, startr, endc, endr) {
		context.globalCompositeOperation="source-over";
		context.strokeStyle="red";
		context.lineWidth = 8;
		context.beginPath();
		context.moveTo(board.width/14+board.width/7*startc, board.height/12+board.height/6*startr);
		context.lineTo(board.width/14+board.width/7*endc, board.height/12+board.height/6*endr);
		context.closePath();
		context.stroke();
		dropPiece();
	}

	function resetGame() {
		enabled = true;
		context.clearRect(0,0,board.width, board.height);
		context.fillStyle="grey";
		context.fillRect(0, 0, 490, 480);
		context.globalCompositeOperation = 'destination-out';
		context.fillStyle="rgba(0,0,0,1)";
		context.beginPath();
		for (var col=0;col<7;col++) {
			for (var row=0;row<6;row++) {
				context.arc(board.width/14 + board.width/7*col, board.height/12 + board.height/6*row, 30, 0, 2*Math.PI, true);
			}
			context.closePath();
			context.fill();
			context.beginPath();
		}
		context.closePath();
		context.fill();
		pieces = new Array();
		lastPiece = -1;
		grid = new Array(6);
		for (var i=0;i<grid.length;i++) {
			grid[i]= new Array(7);
		}
		dropPiece();
	}

	
	</script>
</html>